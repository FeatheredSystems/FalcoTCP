<html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>FalcoTCP</title><link rel="stylesheet" href=""></head><body>

<style> * { margin: 0; padding: 0; box-sizing: border-box; } body { background: #0a0a0a; color: #e5e5e5; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica', 'Arial', sans-serif; line-height: 1.6; position: relative; } .bloom-container { position: fixed; top: 0; left: 0; width: 100%; height: 100vh; pointer-events: none; z-index: 0; overflow: hidden; } .bloom { position: absolute; border-radius: 50%; filter: blur(100px); opacity: 0.08; transition: all 0.5s ease-out; } .bloom-1 { width: 600px; height: 600px; background: radial-gradient(circle, rgba(255, 255, 255, 0.3) 0%, rgba(255, 255, 255, 0) 70%); top: -10%; left: -5%; } .bloom-2 { width: 500px; height: 500px; background: radial-gradient(circle, rgba(255, 255, 255, 0.25) 0%, rgba(255, 255, 255, 0) 70%); top: 20%; right: 10%; } .bloom-3 { width: 700px; height: 700px; background: radial-gradient(circle, rgba(255, 255, 255, 0.2) 0%, rgba(255, 255, 255, 0) 70%); bottom: -15%; left: 15%; } .bloom-4 { width: 450px; height: 450px; background: radial-gradient(circle, rgba(255, 255, 255, 0.15) 0%, rgba(255, 255, 255, 0) 70%); top: 50%; right: 20%; } .bloom-5 { width: 550px; height: 550px; background: radial-gradient(circle, rgba(255, 255, 255, 0.18) 0%, rgba(255, 255, 255, 0) 70%); top: 70%; left: 40%; } section, header { position: relative; z-index: 1; max-width: 900px; margin: 0 auto; padding-left: 3rem; padding-right: 3rem; } h1 { font-size: 2.5rem; font-weight: 700; color: #ffffff; margin-bottom: 1.5rem; margin-top: 2rem; } h2 { font-size: 2rem; font-weight: 600; color: #d4d4d4; margin-top: 3rem; margin-bottom: 1rem; padding-bottom: 0.5rem; border-bottom: 1px solid rgba(255, 255, 255, 0.2); } h3 { font-size: 1.5rem; font-weight: 600; color: #a3a3a3; margin-top: 2rem; margin-bottom: 0.75rem; } p { color: #a3a3a3; margin-bottom: 1rem; font-size: 1rem; } a { color: #d4d4d4; text-decoration: none; transition: color 0.2s; border-bottom: 1px solid rgba(255, 255, 255, 0.3); } a:hover { color: #ffffff; text-decoration: none; } pre { background: rgba(0, 0, 0, 0.6); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; padding: 1.5rem; margin: 1.5rem 0; overflow-x: auto; } code { background: rgba(0, 0, 0, 0.4); border: 1px solid rgba(255, 255, 255, 0.15); border-radius: 4px; padding: 0.2rem 0.4rem; font-family: 'Courier New', 'Consolas', monospace; font-size: 0.9em; color: #e5e5e5; } pre code { background: none; border: none; padding: 0; color: #e5e5e5; } blockquote { background: rgba(255, 255, 255, 0.05); border-left: 4px solid rgba(255, 255, 255, 0.4); padding: 1rem 1.5rem; margin: 1.5rem 0; color: #d4d4d4; } blockquote strong { color: #ffffff; } em, i { color: #d4d4d4; } strong { color: #ffffff; font-weight: 600; } .hl-keyword { color: #ffffff; font-weight: 500; } .hl-type    { color: #d4d4d4; } .hl-func    { color: #e5e5e5; } .hl-string  { color: #a3a3a3; } .hl-number  { color: #b8b8b8; } .hl-comment { color: #525252; font-style: italic; } .hl-field   { color: #c2c2c2; } footer { text-align: center; padding: 4rem 3rem 2rem; color: #737373; font-size: 0.9rem; position: relative; z-index: 1; } </style> 
    <div class="bloom-container">
        <div class="bloom bloom-1"></div>
        <div class="bloom bloom-2"></div>
        <div class="bloom bloom-3"></div>
        <div class="bloom bloom-4"></div>
        <div class="bloom bloom-5"></div>
    </div>
    <script>
        const blooms = document.querySelectorAll('.bloom');

        window.addEventListener('scroll', () => {
            const scrolled = window.pageYOffset;
            const maxScroll = document.documentElement.scrollHeight - window.innerHeight;
            const scrollPercent = scrolled / maxScroll;

            blooms.forEach((bloom, i) => {
                const speed = (i + 1) * 0.15;
                const translateY = scrolled * speed * 0.5;
                const translateX = Math.sin(scrolled * 0.0005 + i) * 30;
                
                const opacity = 0.12 - (scrollPercent * 0.04);
                const blur = 100 + (scrollPercent * 20);
                
                bloom.style.transform = `translate(${translateX}px, ${translateY}px)`;
                bloom.style.opacity = Math.max(0.06, opacity);
                bloom.style.filter = `blur(${blur}px)`;
            });
        });
    </script>
<header>
<br/><br/><h1>FalcoTCP</h1><p>A network handler designed for a trusted endtoend connection, such as a microservicetomicroservice connection. It uses a preshared key for onthefly encryption, for performance's sake.</p><br/>
</header>
<main>
<section id="Networker">
<br/><h1>Networker</h1><p>This is the server engine; it has a clock cycle that handles connections.</p><br/><h2>Headers</h2><p>Every request must include headers; they indicate the payload length and the compression algorithm used (if any). The header size is 9 in bytes, the first 8 bytes being the 64bit unsigned integer that represents the payload size, and a single byte flagging the compression algorithm. Both request and response use this header format.</p>
</section>
<section id="Cycle">
<h2>Cycle</h2><p>The engine is essentially a state manager that operates in cycles. Each one updates the clients it keeps, processing requests and responses at the socket level. A client can be in 11 different states, which are: <i><a href="#NonExistent">NonExistent</a>, <a href="#Idle">Idle</a>, <a href="#HeadersReading">Headers Reading</a>, <a href="#Reading">Reading</a>, <a href="#Finished-Reading">Finished reading</a>, <a href="#Available">Available</a>, <a href="#Processing">Processing</a>, <a href="#Ready">Ready</a>, <a href="#WritingSock">Writing Sock</a>, <a href="#Kill">Kill</a>,</i> and <i><a href="#Finished-Writing">Finished Writing</a></i>.</p>
</section>
<section id="NonExistent">
<h3>NonExistent</h3><p>This state is given to a client that is just allocated, has no socket bound to it, basically a spot for addressing a new connection. Every client, after getting the state <a href="Kill"><i>Kill</i></a> is stated as such.</p>
</section>
<section id="Idle">
<h3>Idle</h3><p>Describes a connection that is opened, but with no processing being done from it. If a connection remains in the state for more than the magic number of 1200 seconds (20 minutes), it gets the state <a href="Kill"><i>Kill</i></a>.</p>
</section>
<section id="HeadersReading">
<h3>Headers reading</h3><p>To check whether a connection made a request or not, it is set to this state (<code>Finished_H</code>internally). If bytes equal to the request method size get read from that client socket, it is set to the state <a href="Reading">Reading</a>, <a href="Idle">Idle</a> otherwise.</p>
</section>
<section id="Reading">
<h3>Reading</h3><p>A state that is given to the client that successfully gets a request, and has its headers read. It requests to read from the socket the byte count set in the headers. To guarantee all bytes will be read, the connection is set to the state <a href="FinishedReading">Finished reading</a>.</p>
</section>
<section id="Finished-Reading">
<h3>Finished reading</h3><p>If the read from <a href="Reading">Reading</a> fails to retrieve the expected count, the client is locked into this state until all bytes requested are read. That said, the state reads the socket until there are no bytes remaining to be read, setting the client to <a href="Available">Available</a> if so.</p>
</section>
<section id="Available">
<h3>Available</h3><p>As a client reaches this state, the server handler in the Rust end can request it and set it to <a href="Processing">Processing</a>, get the request content, process it, embed a response, and send. As the response is linked to the client, its state is set to <a href="Ready">Ready</a>.</p>
</section>
<section id="Processing">
<h3>Processing</h3><p>A state that tells that the Rust end is computing this request.</p>
</section>
<section id="#Ready">
<h3>Ready</h3><p>As a client has this state, the networker acknowledges that it owns the client and can start the socket response writing process. Setting the state to <a href="WritingSock">Writing Sock</a>.</p>
</section>
<section id="WritingSock">
<h3>Writing sock</h3><p>The write version of <a href="Reading">Reading</a>, tries to write, setting it in a state to rewrite in case not all bytes get written at once. The <a href="FinishedWriting">Finished writing</a> state.</p>
</section>
<section id="FinishedWriting">
<h3>Finished writing</h3><p>Rewrite remaining bytes until none are left to be written. As all get written, the cycle rollback, state being set to <a href="Idle">Idle</a>.</p>
</section>
<section id="Kill">
<h3>Kill</h3><p>In cases of malfunction, the client is killed, and related buffers and file descriptors are freed/closed. The state is set back to <a href="NonExistent">NonExistent</a>.</p>
</section>
<section id="Rust-Networker-Implementation">
<h1>Rust Networker Implementation</h1><p><blockquote></p><p>  <strong>Note:</strong> The content below is taken directly from the <code>Networker</code> struct documentation.</p><p></blockquote></p>
<pre><code>
<span class="hl-keyword">pub</span> <span class="hl-keyword">struct</span> <span class="hl-type">Networker</span> {
    <span class="hl-field">primitive_self</span>: <span class="hl-type">RawNetworker</span>,
    <span class="hl-field">mutex</span>: <span class="hl-type">Mutex&lt;()&gt;</span>,
    <span class="hl-field">initilized</span>: <span class="hl-type">u8</span>,
}
</code></pre>
<p><code>Networker</code>wraps a C implementation that uses Linux's io_uring to handle multiple client connections. The server operates in cycles, where each cycle processes pending I/O operations for all connected clients.</p><h2>Structure</h2><p>The networker allocates a fixed number of client slots during initialization. Each slot can hold one client connection and tracks that connection's state through the requestresponse lifecycle.</p><h2>Concurrency</h2><p>This structure implements <code>Send</code>and <code>Sync</code> Internal operations use a mutex to coordinate access to the underlying C structures and client state.</p><h2>Features</h2><p>When the <code>tokio-runtime</code>feature is enabled, methods like <code>cycle()</code>and <code>get_client()</code>become async and integrate with the Tokio runtime. Without this feature, these methods are synchronous.</p><h2>Panics</h2><p>Methods <code>cycle()</code>and <code>get_client()</code>panic if called on an uninitialized <code>Networker</code> Use <code>Networker::new()</code>to initialize before calling these methods. <code>Networker::default()</code>creates an uninitialized instance.</p><h2>Safety</h2><p>This structure wraps C FFI calls and manages raw pointers. Safety is maintained through state management and the internal mutex.</p>
</section>
<section id="Client">
<h1>Client</h1><p>The client implementation is pretty straightforward. Just a structure that holds sockets, in a pool, and you can hold it globally and use it across threads safely. On sending, it passes the blob input into a pipeline. Which either <a href="compress">compress</a>, <a href="encryption">encrypt</a>, or both. It depends on the selected features.</p><h1>Pipelines</h1><p>Process that computes over the input before sending data to the network, based on the entered <a href="features">features</a>. In code, there are <code>pipeline_read</code>and <code>pipeline_write</code> where the difference is simply the order of operations. The read pipe for decrypting and decompressing, the write pipe for compressing and encrypting.</p>
</section>
<section id="encryption">
<h1>Encryption</h1><p>FalcoTCP uses AES256GCM. If you append the <a href="featureencryption">encryption</a> feature, it will encrypt/decrypt data. </p>
</section>
<section id="compress">
<h1>Compression</h1><p>There are four options: LZMA, LZ4, ZSTD, and GZIP. You pick one yourself if the <a href="heuristics">heuristics</a> feature is absent. Otherwise, the program picks one based on the packet size, and <a href="heuristicsbias">heuristicsbias</a>. </p>
</section>
<section href="heuristics">
<h1>Heuristics</h1><p>In this case, heuristics are used to pick which compression algorithm will be used depending on the package size. Since there are four algorithms, and some (LZMA, especially) might be very slow, there is a "bias" you can apply to the heuristics, which are the heuristicbias.</p>
</section>
<section id="heuristics-bias">
<h2>Heuristic bias</h2><h3>Performance</h3><p>Always picks LZ compression, falling back to other algorithms (in the same sequence) if not available: ZSTD, and GZIP. </p><h3>Ratio</h3><p>Pick up a different algorithm based on size and availability. At 10MiB or less, it will pick LZMA, falling back to GZIP, ZSTD, or LZ4. If between 10Mib and 200Mib, it will pick GZIP, falling back to ZSTD, or LZ4. If within the range of 200Mib and 300Mib, ZSTD will be picked, falling to GZIP if not available. If 300Mib+, LZ4 will always be picked.</p><h3>Balance</h3><p>If below 10MiB, it will pick LZMA, falling back to ZSTD, GZIP, or LZ4, depending on availability. In the range of 10MiB to 200MiB, GZIP, ZSTD, or LZ4 will be picked. Between 200MiB and 300MiB, either GZIP or ZSTD will be picked. If the packet size is higher than 300MiB, LZ4 is selected. </p>
</section>
<section id="features">
<h1><a href="https://doc.rustlang.org/cargo/reference/features.html">Features</a></h1><p> <b>heuristics</b>: Add heuristics to the compression algorithm selection.</p><p> <b>heubias-performance</b>: Set the heuristics to drive towards performance.</p><p> <b>heubias-ratio</b>: Make heuristics pick what has the highest coherent compression ratio.</p><p> <b>heubias-balance</b>: Makes heuristics balance between performance and ratio, picked by default if no bias is selected.</p><p> <b>complete-compression</b>: Include all four compression algorithms (LZ4, ZSTD, GZIP, and LZMA). I would recommend this for servers.</p><p> <b>tokio-runtime</b>: Makes it use the asynchronous tokio runtime.</p><p> <b>client</b>: Include the client handling primitives.</p><p> <b>server</b>: Include the server handling primitives.</p><p> <b>falco-client</b>: Include the FalcoTCP client side integration (pipelines et cetra).</p><p> <b>falco-server</b>: Also include the FalcoTCP integration, but with serverside only.</p><p> <b>LZMA</b>: Include LZMA</p><p> <b>LZ4</b>: Include LZ4</p><p> <b>GZIP</b>: Include GZIP</p><p> <b>ZSTD</b>: Include ZSTD</p><p> <b>dynamic-io-uring-link</b>: Changes the compilation process, including liburing dynamically instead of the default (static).</p><p> <b>dev-redundancies</b>: Include quirks I thought that could be useful, or help with efficiency, yet have tradeoffs that can make the balance shift to more inefficiency later, depending on the project's use. Mostly <code>shrink_to_fit</code> everywhere I think someone might leave some capacity idle. That said, it allows me to put more of "me" (whatever it means) into the codebase.</p>
</section>
</main>
<footer style="text-align:center;">
:)
</footer>
<br/></body></html>